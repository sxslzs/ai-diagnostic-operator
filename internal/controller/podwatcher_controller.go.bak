package controller

import (
	"context"
	"fmt"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/event"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"

	diagnosticv1 "github.com/sxslzs/ai-diagnostic-operator/api/v1"
)

// PodWatcherReconciler 监听 Pod 失败事件，自动创建 PodDiagnosis
type PodWatcherReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;watch
// +kubebuilder:rbac:groups=diagnostic.sre.example.com,resources=poddiagnoses,verbs=create;get;list;update;patch;delete
// +kubebuilder:rbac:groups=diagnostic.sre.example.com,resources=poddiagnoses/status,verbs=get

// Reconcile 处理 Pod 对象
func (r *PodWatcherReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// 1. 获取 Pod
	var pod corev1.Pod
	if err := r.Get(ctx, req.NamespacedName, &pod); err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// 2. 判断 Pod 是否处于失败状态
	if !isPodFailed(&pod) {
		return ctrl.Result{}, nil
	}

	// 3. 检查是否已存在针对该 Pod 的 PodDiagnosis（避免重复创建）
	// 通过标签快速过滤（需确保索引已设置，或使用 client.MatchingFields）
	diagnosisList := &diagnosticv1.PodDiagnosisList{}
	if err := r.List(ctx, diagnosisList,
		client.InNamespace(pod.Namespace),
		client.MatchingLabels{"diagnosed-pod": pod.Name}); err != nil {
		logger.Error(err, "无法查询现有的 PodDiagnosis")
		return ctrl.Result{}, err
	}

	// 如果已有未完成（非终态）的诊断，则跳过
	for _, d := range diagnosisList.Items {
		if d.Status.Phase != "Completed" && d.Status.Phase != "Failed" {
			logger.Info("该 Pod 已有正在进行的诊断，跳过", "diagnosis", d.Name)
			return ctrl.Result{}, nil
		}
		// 可选：如果已完成但间隔时间较长，可以再次诊断（这里简单返回）
		// 若需再次诊断，可检查诊断时间与当前时间间隔
		return ctrl.Result{}, nil
	}

	// 4. 创建新的 PodDiagnosis
	diagnosis := &diagnosticv1.PodDiagnosis{
		ObjectMeta: metav1.ObjectMeta{
			GenerateName: fmt.Sprintf("%s-diagnosis-", pod.Name),
			Namespace:    pod.Namespace,
			Labels: map[string]string{
				"diagnosed-pod": pod.Name,
				"created-by":    "pod-watcher",
			},
		},
		Spec: diagnosticv1.PodDiagnosisSpec{
			PodName:       pod.Name,
			Namespace:     pod.Namespace,
			TriggerReason: fmt.Sprintf("Pod entered failed state: %s", getFailureReason(&pod)),
			TailLines:     100, // 可配置化，建议从环境变量或 ConfigMap 读取
		},
	}

	// 设置 OwnerReference，当 Pod 删除时自动清理诊断
	if err := controllerutil.SetControllerReference(&pod, diagnosis, r.Scheme); err != nil {
		logger.Error(err, "无法设置 OwnerReference")
		return ctrl.Result{}, err
	}

	if err := r.Create(ctx, diagnosis); err != nil {
		logger.Error(err, "无法创建 PodDiagnosis")
		return ctrl.Result{}, err
	}

	logger.Info("成功为失败 Pod 创建诊断任务", "pod", pod.Name, "diagnosis", diagnosis.Name)
	return ctrl.Result{}, nil
}

// SetupWithManager 设置控制器，并添加事件过滤器
func (r *PodWatcherReconciler) SetupWithManager(mgr ctrl.Manager) error {
	// 只处理 Pod 创建和更新事件，且仅在 Pod 进入失败状态时触发
	return ctrl.NewControllerManagedBy(mgr).
		For(&corev1.Pod{}).
		WithEventFilter(predicate.Funcs{
			CreateFunc: func(e event.CreateEvent) bool {
				pod, ok := e.Object.(*corev1.Pod)
				return ok && isPodFailed(pod)
			},
			UpdateFunc: func(e event.UpdateEvent) bool {
				oldPod, okOld := e.ObjectOld.(*corev1.Pod)
				newPod, okNew := e.ObjectNew.(*corev1.Pod)
				if !okOld || !okNew {
					return false
				}
				// 仅当从非失败状态变为失败状态时触发
				return !isPodFailed(oldPod) && isPodFailed(newPod)
			},
			DeleteFunc:  func(e event.DeleteEvent) bool { return false },
			GenericFunc: func(e event.GenericEvent) bool { return false },
		}).
		Complete(r)
}

// isPodFailed 判断 Pod 是否处于失败状态
func isPodFailed(pod *corev1.Pod) bool {
	// Pod Phase 为 Failed
	if pod.Status.Phase == corev1.PodFailed {
		return true
	}
	// 所有容器都已终止且至少有一个退出码非零
	allTerminated := true
	hasNonZero := false
	for _, status := range pod.Status.ContainerStatuses {
		if status.State.Terminated == nil {
			allTerminated = false
			break
		}
		if status.State.Terminated.ExitCode != 0 {
			hasNonZero = true
		}
	}
	return allTerminated && hasNonZero
}

// getFailureReason 提取简要失败原因
func getFailureReason(pod *corev1.Pod) string {
	if pod.Status.Phase == corev1.PodFailed {
		for _, cond := range pod.Status.Conditions {
			if cond.Type == corev1.PodReasonUnschedulable && cond.Status == corev1.ConditionTrue {
				return "Unschedulable: " + cond.Message
			}
		}
	}
	for _, status := range pod.Status.ContainerStatuses {
		if status.State.Terminated != nil && status.State.Terminated.ExitCode != 0 {
			return fmt.Sprintf("Container %s exited with code %d: %s",
				status.Name, status.State.Terminated.ExitCode, status.State.Terminated.Reason)
		}
	}
	return "unknown failure"
}
